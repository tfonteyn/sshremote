package com.hardbacknutter.sshclient.parsing;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.hardbacknutter.sshclient.DbgJLogger;
import com.hardbacknutter.sshclient.SshClient;
import com.hardbacknutter.sshclient.keypair.SshKeyPair;
import com.hardbacknutter.sshclient.keypair.util.KeyPairTool;
import com.hardbacknutter.sshclient.keypair.util.KeyPairWriter;
import com.hardbacknutter.sshclient.signature.SshSignature;

import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.Arguments;
import org.junit.jupiter.params.provider.MethodSource;

import java.io.File;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.util.stream.Stream;


class KeyPairTest {

    private static final String TEST_RESOURCES = "src/test/resources/";
    private static final String PASSWORD = "qwerty";
    private static final String SSH_DSS = "ssh-dss";
    private static final String SSH_RSA = "ssh-rsa";
    private static final String ECDSA_SHA_2_NISTP_256 = "ecdsa-sha2-nistp256";
    private static final String ECDSA_SHA_2_NISTP_384 = "ecdsa-sha2-nistp384";
    private static final String ECDSA_SHA_2_NISTP_521 = "ecdsa-sha2-nistp521";
    private static final String SSH_ED_25519 = "ssh-ed25519";

    private static final SshClient SSH_CLIENT = new SshClient(new DbgJLogger());

    private static final String longText =
            "Status of This Memo\n"
                    + "\n"
                    + "   This document specifies an Internet standards track protocol for the\n"
                    + "   Internet community, and requests discussion and suggestions for\n"
                    + "   improvements.  Please refer to the current edition of the \"Internet\n"
                    + "   Official Protocol Standards\" (STD 1) for the standardization state\n"
                    + "   and status of this protocol.  Distribution of this memo is unlimited.\n"
                    + "\n"
                    + "Copyright Notice\n"
                    + "\n"
                    + "   Copyright (C) The Internet Society (2006).\n"
                    + "\n"
                    + "Abstract\n"
                    + "\n"
                    + "   The Secure Shell (SSH) is a protocol for secure remote login and\n"
                    + "   other secure network services over an insecure network.\n"
                    + "\n"
                    + "   This document describes the SSH transport layer protocol, which\n"
                    + "   typically runs on top of TCP/IP.  The protocol can be used as a basis\n"
                    + "   for a number of secure network services.  It provides strong\n"
                    + "   encryption, server authentication, and integrity protection.  It may\n"
                    + "   also provide compression.\n"
                    + "\n"
                    + "   Key exchange method, public key algorithm, symmetric encryption\n"
                    + "   algorithm, message authentication algorithm, and hash algorithm are\n"
                    + "   all negotiated.\n"
                    + "\n"
                    + "   This document also describes the Diffie-Hellman key exchange method\n"
                    + "   and the minimal set of algorithms that are needed to implement the\n"
                    + "   SSH transport layer protocol.\n";

    @NonNull
    static Stream<Arguments> readAndWriteArgs() {
        return Stream.of(
                Arguments.of("legacy/dsa", null, SSH_DSS),
                Arguments.of("legacy/dsa_qwerty", PASSWORD, SSH_DSS),
                Arguments.of("legacy/rsa", null, SSH_RSA),
                Arguments.of("legacy/rsa_qwerty", PASSWORD, SSH_RSA),

                Arguments.of("legacy/ecdsa256", null, ECDSA_SHA_2_NISTP_256),
                Arguments.of("legacy/ecdsa256_qwerty", PASSWORD, ECDSA_SHA_2_NISTP_256),
                Arguments.of("legacy/ecdsa384", null, ECDSA_SHA_2_NISTP_384),
                Arguments.of("legacy/ecdsa384_qwerty", PASSWORD, ECDSA_SHA_2_NISTP_384),
                Arguments.of("legacy/ecdsa521", null, ECDSA_SHA_2_NISTP_521),
                Arguments.of("legacy/ecdsa521_qwerty", PASSWORD, ECDSA_SHA_2_NISTP_521),

                /*
                 * Just a sanity check. - same as ecdsa but generated by:
                 * <p>
                 * openssl ecparam -name secp256r1 -out secp256r1.param
                 * openssl ecparam -in .\secp256r1.param -genkey -noout -out .\secp256r1
                 * openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in .\secp256r1 -out pkcs8_secp256r1.key
                 * <p>
                 * openssl ec -in secp256r1 -pubout -out secp256r1.pub
                 */
                Arguments.of("legacy/pkcs8_secp256r1", null, ECDSA_SHA_2_NISTP_256),

                Arguments.of("opensshv1/id_dsa", null, SSH_DSS),
                Arguments.of("opensshv1/id_dsa_qwerty", PASSWORD, SSH_DSS),
                Arguments.of("opensshv1/id_rsa", null, SSH_RSA),
                Arguments.of("opensshv1/id_rsa_qwerty", PASSWORD, SSH_RSA),

                Arguments.of("opensshv1/id_ecdsa_256", null, ECDSA_SHA_2_NISTP_256),
                Arguments.of("opensshv1/id_ecdsa_384", null, ECDSA_SHA_2_NISTP_384),
                Arguments.of("opensshv1/id_ecdsa_521", null, ECDSA_SHA_2_NISTP_521),

                Arguments.of("opensshv1/id_ecdsa_256_qwerty", PASSWORD, ECDSA_SHA_2_NISTP_256),
                Arguments.of("opensshv1/id_ecdsa_384_qwerty", PASSWORD, ECDSA_SHA_2_NISTP_384),
                Arguments.of("opensshv1/id_ecdsa_521_qwerty", PASSWORD, ECDSA_SHA_2_NISTP_521),
                Arguments.of("opensshv1/id_ed25519", null, SSH_ED_25519),
                Arguments.of("opensshv1/id_ed25519_qwerty", PASSWORD, SSH_ED_25519)
        );
    }

    @NonNull
    static Stream<Arguments> readOnlyArgs() {
        return Stream.of(
                Arguments.of("putty2/dsa_qwerty.ppk", PASSWORD, SSH_DSS),
                Arguments.of("putty2/rsa_qwerty.ppk", PASSWORD, SSH_RSA),
                Arguments.of("putty2/ecdsa256_qwerty.ppk", PASSWORD, ECDSA_SHA_2_NISTP_256),

                Arguments.of("putty3/dsa.ppk", null, SSH_DSS),
                Arguments.of("putty3/dsa_qwerty.ppk", PASSWORD, SSH_DSS),
                Arguments.of("putty3/rsa.ppk", null, SSH_RSA),
                Arguments.of("putty3/rsa_qwerty.ppk", PASSWORD, SSH_RSA),
                Arguments.of("putty3/ecdsa256.ppk", null, ECDSA_SHA_2_NISTP_256),
                Arguments.of("putty3/ecdsa256_qwerty.ppk", PASSWORD, ECDSA_SHA_2_NISTP_256),
                Arguments.of("putty3/ed25519.ppk", null, SSH_ED_25519),
                Arguments.of("putty3/ed25519_qwerty.ppk", PASSWORD, SSH_ED_25519)
        );
    }

    @NonNull
    static Stream<Arguments> readDualArgs() {
        return Stream.of(
                /*
                  openssl dsaparam -out pkcs8_dsa.param 2048
                  openssl gendsa -out pkcs8_dsa.pem pkcs8_dsa.param
                  openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in pkcs8_dsa.pem -out pkcs8_dsa.key
                  openssl dsa -in pkcs8_dsa.pem -outform PEM -pubout -out pkcs8_dsa.pub
                 */
                Arguments.of("openssl/pkcs8_dsa.key", "openssl/pkcs8_dsa.pub", null, SSH_DSS),
                /*
                  openssl genrsa -out pkcs8_rsa.pem 2048
                  openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in pkcs8_rsa.pem -out pkcs8_rsa.key
                  openssl rsa -in pkcs8_rsa.pem -outform PEM -pubout -out pkcs8_rsa.pub
                 */
                Arguments.of("openssl/pkcs8_rsa.key", "openssl/pkcs8_rsa.pub", null, SSH_RSA),

                /*
                  openssl ecparam -name secp256r1 -out pkcs8_secp256r1.param
                  openssl ecparam -in pkcs8_secp256r1.param -genkey -noout -out pkcs8_secp256r1.pem
                  openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in pkcs8_secp256r1.pem -out pkcs8_secp256r1.key
                  openssl ec -in pkcs8_secp256r1.pem -pubout -out pkcs8_secp256r1.pub
                 */
                Arguments.of("openssl/pkcs8_secp256r1.key",
                             "openssl/pkcs8_secp256r1.pub", null, ECDSA_SHA_2_NISTP_256),
                /*
                  openssl ecparam -name secp384r1 -out pkcs8_secp384r1.param
                  openssl ecparam -in pkcs8_secp384r1.param -genkey -noout -out pkcs8_secp384r1.pem
                  openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in pkcs8_secp384r1.pem -out pkcs8_secp384r1.key
                  openssl ec -in pkcs8_secp384r1.pem -pubout -out pkcs8_secp384r1.pub
                 */
                Arguments.of("openssl/pkcs8_secp384r1.key",
                             "openssl/pkcs8_secp384r1.pub", null, ECDSA_SHA_2_NISTP_384),
                /*
                  openssl ecparam -name secp521r1 -out pkcs8_secp521r1.param
                  openssl ecparam -in pkcs8_secp521r1.param -genkey -noout -out pkcs8_secp521r1.pem
                  openssl pkcs8 -topk8 -inform PEM -outform PEM -nocrypt -in pkcs8_secp521r1.pem -out pkcs8_secp521r1.key
                  openssl ec -in pkcs8_secp521r1.pem -pubout -out pkcs8_secp521r1.pub
                 */
                Arguments.of("openssl/pkcs8_secp521r1.key",
                             "openssl/pkcs8_secp521r1.pub", null, ECDSA_SHA_2_NISTP_521)
        );
    }

    @ParameterizedTest
    @MethodSource("readAndWriteArgs")
    void readAndWrite(@NonNull final String path,
                      @Nullable final String password,
                      @NonNull final String keyType)
            throws IOException, GeneralSecurityException {

        final SshKeyPair kp = parseFile(TEST_RESOURCES + path, null, password, keyType);
        write(kp, null);
        signAndVerify(kp);
    }

    @ParameterizedTest
    @MethodSource("readOnlyArgs")
    void readOnly(@NonNull final String path,
                  @Nullable final String password,
                  @NonNull final String keyType)
            throws IOException, GeneralSecurityException {

        final SshKeyPair kp = parseFile(TEST_RESOURCES + path, null, password, keyType);
        write(kp, null);
        signAndVerify(kp);
    }

    @ParameterizedTest
    @MethodSource("readDualArgs")
    void readDual(@NonNull final String prv,
                  @NonNull final String pub,
                  @Nullable final String password,
                  @NonNull final String keyType)
            throws IOException, GeneralSecurityException {

        final SshKeyPair kp = parseFile(TEST_RESOURCES + prv,
                                        TEST_RESOURCES + pub, password, keyType);
        write(kp, null);
        signAndVerify(kp);
    }

    SshKeyPair parseFile(@NonNull final String prvFilename,
                         @Nullable final String pubFilename,
                         @Nullable final String passPhrase,
                         @NonNull final String keyType)
            throws IOException, GeneralSecurityException {

        final String prv = new File(prvFilename).getAbsolutePath();
        final String pub = pubFilename != null ? new File(pubFilename).getAbsolutePath() : null;

        final KeyPairTool keyPairTool = new KeyPairTool(SSH_CLIENT.getConfig());
        final SshKeyPair keyPair = keyPairTool.load(prv, pub);
        assertNotNull(keyPair);

        final byte[] pp = passPhrase != null ? passPhrase.getBytes(StandardCharsets.UTF_8) : null;
        assertTrue(keyPair.decryptPrivateKey(pp), "Failed to decrypt");
        assertEquals(keyType, keyPair.getHostKeyAlgorithm());

        return keyPair;
    }

    void signAndVerify(@NonNull final SshKeyPair keyPair)
            throws GeneralSecurityException, IOException {
        final byte[] text = longText.getBytes(StandardCharsets.UTF_8);

        final String hostKeyAlgorithm = keyPair.getHostKeyAlgorithm();
        final byte[] sig = keyPair.getSignature(text, hostKeyAlgorithm);
        final SshSignature verifier = keyPair.getVerifier();
        verifier.update(text);
        assertTrue(verifier.verify(sig));
    }

    void write(@NonNull final SshKeyPair keyPair,
               @Nullable final String passPhrase)
            throws GeneralSecurityException {
        final KeyPairWriter keyPairWriter = new KeyPairWriter();

        try (final PrintWriter out = new PrintWriter(System.out, true, StandardCharsets.UTF_8)) {
            keyPairWriter.writePublicKey(keyPair, out, keyPair.getPublicKeyComment());
        }
    }
}
